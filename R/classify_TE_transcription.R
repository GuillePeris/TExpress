#' Classify TE Transcription as Self-Expressed or Gene-Dependent
#'
#' Classifies transposable elements based on their transcriptional origin:
#' TEs transcribed from their own promoters (self-expressed) vs. TEs
#' transcribed as part of host gene transcription (gene-dependent/runthrough).
#' Classification follows the methodology of Chang et al. (2021) and has been 
#' updated in Gázquez-Gutiérrez et al (2026).
#'
#' @param TE_results List object returned by \code{\link{annotate_TE_regions}}, containing:
#'   \describe{
#'     \item{res.TEs}{Data frame of DESeq2 results for TEs with genomic annotations}
#'     \item{TE.count}{Data frame of normalized counts for TEs}
#'     \item{gene.count}{Data frame of normalized counts for genes}
#'     \item{metadata}{Sample metadata}
#'   }
#' @param output_folder Character string. Directory for saving results.
#'   A subdirectory "classify_TE" will be created. Default is current directory.
#' @param minNormCounts Numeric. Minimum normalized count threshold for
#'   considering a feature "expressed". A feature must have normalized 
#'   counts >= this value in at least one condition to be considered expressed.
#'   Default is 10.
#' @param maxpadj Numeric. Maximum adjusted p-value for filtering significantly
#'   dysregulated TEs when \code{save != "all"}. Default is 0.05.
#' @param minlfc Numeric. Minimum absolute log2 fold change for filtering
#'   significantly dysregulated TEs when \code{save != "all"}. Default is 1.
#' @param TE_list Character vector. TE classes to include in classification.
#'   Default is c("LTR", "LINE", "DNA", "SINE").
#' @param antisense Logical. If TRUE, classifies TEs in antisense orientation
#'   as gene-dependent. Requires antisense GTF generated by
#'   \code{\link{gtfBothStrands}}. Default is FALSE.
#' @param antisense_suffix Character string. Suffix used to identify antisense
#'   features in TE_element names. Default is "_AS".
#' @param save Character string. Which TEs to save in output file:
#'   \itemize{
#'     \item "all": All expressed TEs (default)
#'     \item "dys": Only significantly dysregulated TEs (up or down)
#'     \item "up": Only significantly upregulated TEs
#'     \item "down": Only significantly downregulated TEs
#'   }
#' @param plot.title Character string. Title for classification pie charts.
#'   If NULL, no title is displayed. Default is NULL.
#' @param device Character vector. File format(s) for output plots.
#'   Default is "png".
#' @param width Numeric. Plot width in inches. Default is 28.
#' @param height Numeric. Plot height in inches. Default is 7.
#'
#' TEs are classified into two broad categories:
#' \enumerate{
#'   \item \strong{Gene-dependent (runthrough transcription)}:
#'     \itemize{
#'       \item \strong{Exon}: TE overlaps exon, 5'UTR, or 3'UTR on same strand
#'       \item \strong{Intron (expressed)}: TE in intron of expressed gene, same strand
#'       \item \strong{Antisense}: TE on opposite strand (if \code{antisense = TRUE})
#'     }
#'   \item \strong{Self-expressed (autonomous transcription)}:
#'     \itemize{
#'       \item \strong{Intron (not expressed)}: TE in intron of non-expressed gene
#'       \item \strong{Non read-through}: All other cases (promoters, intergenic, etc.)
#'     }
#' }
#'
#' \strong{Classification Hierarchy:}
#'
#' When a TE could fit multiple categories, the most restrictive is chosen:
#' Exon > Intron (expressed) > Antisense > Intron (not expressed) > Non read-through
#'
#' \strong{Expression Determination:}
#'
#' A gene/TE is considered "expressed" if it has normalized counts ≥ \code{minNormCounts}
#' in at least one condition (Control or Treat).
#'
#' @section Output Files:
#' \preformatted{
#' output_folder/
#'   └── classify_TE/
#'       ├── DESeq2_TE_results_classified_<save>.tsv
#'       └── pie_TE_classes.<device>
#' }
#'
#' @return TE_results list with updated components
#'
#' @references
#' Chang NC, Rovira Q, Wells J, Feschotte C, Vaquerizas JM. (2022)
#' Zebrafish transposable elements show extensive diversification in age, 
#' genomic distribution, and developmental expression. 
#' Genome Res. 2022 Jul;32(7):1408-1423. \doi{10.1101/gr.275655.121}
#' Gázquez-Gutiérrez, A., et al. (2026)
#' Control of retrotransposon-driven activation of the interferon response 
#' by the double-stranded RNA binding protein DGCR8.
#' Nucleic Acid Research (in press).
#' @export
#'
#' @examples
#' \dontrun{
#' # Run TE DEA first
#' TE_results <- TE_DEA(
#'   metafile = "metadata.txt",
#'   folder = "counts",
#'   gtf.TE.file = "TEs.gtf"
#' )
#'
#' # Annotate TEs and generate region plots
#' TE_results_annotated <- annotate_TE_regions(
#'   TE_results = TE_results,
#'   gtf.genes.file = "genes.gtf",
#'   output_folder = "results",
#'   device = c("jpeg", "png"),
#'   plot.title = "TE Distribution by Genomic Region",
#'   minCounts = 10
#' )
#'
#' # Classify TE transcription
#' TE_results <- classify_TE_transcription(
#'   TE_results = TE_results_annotated,
#'   output_folder = "results",
#'   minNormCounts = 10,
#'   save = "all",
#'   plot.title = "TE Classification"
#' )
#' }
#'

classify_TE_transcription <- function(TE_results,
                                      output_folder = ".",
                                      minNormCounts = 10,
                                      maxpadj = 0.05,
                                      minlfc = 1,
                                      TE_list = c("LTR", "LINE", "DNA", "SINE"),
                                      antisense = FALSE,
                                      antisense_suffix = "_AS",
                                      save = "all",
                                      plot.title = NULL,
                                      device = "png",
                                      width = 28,
                                      height = 7) {

  message("============================================") 
  message("    TE loci transcription classification    ")
  message("============================================") 
  
  
  # Input validation
  if (missing(TE_results)) {
    stop("Argument 'TE_results' is missing with no default.", call. = FALSE)
  }
  
  if (!is.list(TE_results)) {
    stop("'TE_results' must be a list.", call. = FALSE)
  }
  
  # Check required elements
  required_elements <- c("res.TEs", "TE.count", "metadata")
  missing_elements <- setdiff(required_elements, names(TE_results))
  
  if (length(missing_elements) > 0L) {
    stop(
      "'TE_results' must contain elements: ",
      paste(required_elements, collapse = ", "),
      "\nMissing: ", paste(missing_elements, collapse = ", "),
      call. = FALSE
    )
  }
  
  # Extract list elements 
  TE.count <- TE_results$TE.count 
  gene.count <- TE_results$gene.count
  metadata <- TE_results$metadata
  res.TEs <- TE_results$res.TEs
  
  if (!is.data.frame(res.TEs) || nrow(res.TEs) == 0L) {
    stop("'TE_results$res.TEs' must be a non-empty data frame.", call. = FALSE)
  }
  
  if (!is.data.frame(TE.count) || nrow(TE.count) == 0L) {
    stop("'TE_results$TE.count' must be a non-empty data frame.", call. = FALSE)
  }
  
  if (!is.data.frame(gene.count) || nrow(gene.count) == 0L) {
    stop("'TE_results$gene.count' must be a non-empty data frame.", call. = FALSE)
  }
  
  if (!is.data.frame(metadata) || nrow(metadata) == 0L) {
    stop("'TE_results$metadata' must be a non-empty data frame.", call. = FALSE)
  }
  
  # Check required columns in res.TEs
  required_te_cols <- c(
    "TE_class", "annotation", "strand", "geneStrand",
    "geneId", "TE_element", "padj", "log2FoldChange"
  )
  missing_te_cols <- setdiff(required_te_cols, colnames(res.TEs))
  if (length(missing_te_cols) > 0L) {
    stop(
      "'res.TEs' must contain columns: ",
      paste(required_te_cols, collapse = ", "),
      "\nMissing: ", paste(missing_te_cols, collapse = ", "),
      "\nDid you run TE_regionAnnot() to add genomic annotations?",
      call. = FALSE
    )
  }
  
  valid_save <- c("all", "dys", "up", "down")
  if (!save %in% valid_save) {
    stop(
      "'save' must be one of: ",
      paste(valid_save, collapse = ", "),
      "\nProvided: ", save,
      call. = FALSE
    )
  }
  
  # ============================================================
  # Step 1: Get expressed features
  # ============================================================
  message("==> Getting expressed features.")
  start.time <- Sys.time()
  
  # Pre-compute sample groups once
  # sample_groups <- metadata %>%
  #   dplyr::filter(.data$Condition %in% c("Control", "Treat")) %>%
  #   split(.$Condition)
  
  filtered_metadata <- metadata %>%
    dplyr::filter(.data$Condition %in% c("Control", "Treat"))
  
  sample_groups <- split(filtered_metadata, filtered_metadata$Condition)
  
  # Filter selected TEs by class
  res.TEs <- res.TEs %>% 
    dplyr::filter(.data$TE_class %in% TE_list)
  
  # Get expressed TEs and genes
  expressed.TEs <- .get_expressed_features(sample_groups, TE.count, minNormCounts)
  expressed.genes <- .get_expressed_features(sample_groups, gene.count, minNormCounts)    
  
  # ============================================================
  # Step 2: Classify TE transcription
  # ============================================================
  message("==> TE transcription classification.")

  # Initialize to NA
  res.TEs$expression_type <- NA
  res.TEs$TE_expression <- NA
  
  #    + Ex:        Exon (SS)
  index.ex <- is.na(res.TEs$TE_expression) &
              res.TEs$annotation %in% c("Exon", "3' UTR", "5' UTR") &
              res.TEs$strand == res.TEs$geneStrand
  res.TEs[index.ex, ]$TE_expression <- "dependent"
  res.TEs[index.ex, ]$expression_type <- "Exon"
  
  #    + In_g:      Intron (SS) gene expression
  index.in_g <- is.na(res.TEs$TE_expression) & 
                res.TEs$annotation %in% c("Intron") & 
                res.TEs$geneId %in% expressed.genes &
                res.TEs$strand == res.TEs$geneStrand
  
  res.TEs[index.in_g, ]$TE_expression <- "dependent"
  res.TEs[index.in_g, ]$expression_type <- "Intron expressed"
  
  #    + In_ng:     Intron no gene expression
  index.in_ng <- is.na(res.TEs$TE_expression) & 
                 res.TEs$annotation %in% c("Intron") & 
                 !(res.TEs$geneId %in% expressed.genes) &
    res.TEs$strand == res.TEs$geneStrand
  
  res.TEs[index.in_ng, ]$TE_expression <- "self"
  res.TEs[index.in_ng, ]$expression_type <- "Intron no expressed"
  
  #    + Antisense:     TE_strand != tx_strand
  if(antisense) {
    index.antisense <- is.na(res.TEs$TE_expression) & 
                       endsWith(res.TEs$TE_element, antisense_suffix) 
    
    res.TEs[index.antisense, ]$TE_expression <- "dependent"
    res.TEs[index.antisense, ]$expression_type <- "Antisense"
  }
  
  #    + nRT:       Non read-through 
  index.nRT <- is.na(res.TEs$TE_expression)
  res.TEs[index.nRT, ]$expression_type <- "nRT"
  res.TEs[index.nRT, ]$TE_expression <- "self"
  
  res.TEs$expression_type <- factor(res.TEs$expression_type)
  
  # ============================================================
  # Step 3: Save Results
  # ============================================================
  
  message("==> Saving classification results")  

  output_folder <- file.path(output_folder, "classify_TE")
  
  # Create output folder if it doesn't exist
  if (!dir.exists(output_folder)) {
    tryCatch(
      {
        dir.create(output_folder, recursive = TRUE)
      },
      error = function(e) {
        stop(
          "Failed to create output directory '", output_folder, "': ",
          e$message,
          call. = FALSE
        )
      }
    )
  }
  
  # File name
  output.TE.res.file <- file.path(output_folder, 
                                  paste0("DESeq2_TE_results_classified_",
                                  save,
                                  ".tsv")
                                  )

  # Filter TEs to save. First, only expressed TEs are kept.
  res.out <- res.TEs[rownames(res.TEs) %in% expressed.TEs, , drop = FALSE]
  # res.out <- res.TEs %>% 
  #   dplyr::filter(row.names(.) %in% expressed.TEs)
  
  if(save == "dys") {
    res.out <- res.out %>% 
      dplyr::filter(.data$padj <= maxpadj, abs(.data$log2FoldChange) >= minlfc)
  } else if (save == "up") {
    res.out <- res.out %>% 
      dplyr::filter(.data$padj <= maxpadj, .data$log2FoldChange >= minlfc)
  } else if (save == "down") {
    res.out <- res.out %>% 
      dplyr::filter(.data$padj <= maxpadj, .data$log2FoldChange <= -minlfc)
  }  
  
  tryCatch(
    {
      utils::write.table(
        res.out,
        file = output.TE.res.file,
        sep = "\t",
        quote = FALSE,
        row.names = TRUE,
        col.names = NA
      )
    },
    error = function(e) {
      stop("Failed to save TE results: ", e$message, call. = FALSE)
    }
  )
  
  # ============================================================
  # Step 4: Generate Plots
  # ============================================================
  message("==> Generating plots")  

  # Prepare plot title
  if (is.null(plot.title)) {
    if (save != "all") {
      final_title <- paste0("TE Classification - ", save, "regulated TEs")
    } else {
      final_title <- "TE Classification - All Expressed TEs"
    }
  } else {
    if (save != "all") {
      final_title <- paste0(plot.title, " - ", save, "regulated TEs")
    } else {
      final_title <- paste0(plot.title, " - All Expressed TEs")
    }
  }
  
  # Generate pie charts
  tryCatch(
    {
      TE_classify_pie(
        res = res.out,
        plot.title = final_title,
        device = device,
        width = width,
        height = height,
        output_folder = output_folder,
        save = save
      )
    },
    error = function(e) {
      warning(
        "Failed to generate classification pie charts: ", e$message,
        call. = FALSE
      )
    }
  )
  end.time <- Sys.time()
  duration <- difftime(end.time, start.time, units="secs")
  message("       -> Finished TE loci transcription classification. (", 
          round(duration[[1]], 2), " seconds).")
  
  # Create return list with updated res.TEs  
  TE_results <- list(
    res.TEs = res.TEs,
    TE.count = TE.count,
    gene.count = gene.count,
    metadata = metadata
  ) 
  
  TE_results
}

#' Get Expressed Features Based on Minimum Counts
#'
#' Identifies features (genes or TEs) that are expressed in at least one
#' sample group based on a minimum normalized count threshold.
#'
#' @param sample_groups List of data frames split by Condition
#' @param counts.df Data frame of normalized counts with samples as columns
#' @param minNormCounts Numeric threshold for expression
#'
#' @return Character vector of expressed feature names (rownames)
#' @keywords internal
#' @noRd
#'
.get_expressed_features <- function(sample_groups, counts.df, minNormCounts) {
  # Calculate minimums in one pass
  min_cols <- as.data.frame(
    lapply(sample_groups, function(grp) {
      matrixStats::rowMins(as.matrix(counts.df[, grp$Sample]), na.rm = TRUE)
      #apply(as.matrix(counts.df[, grp$Sample]), 1, min, na.rm = TRUE) 
    }))
  
  # Add to norm.counts with proper names
  colnames(min_cols) <- paste0("min_", names(sample_groups))
  counts.df <- cbind(counts.df, min_cols)
  
  # Filter expressed genes and TEs
  min_matrix <- as.matrix(counts.df[, startsWith(colnames(counts.df), "min_")])
  expressed <- counts.df %>%
    dplyr::filter(matrixStats::rowMaxs(min_matrix) >= minNormCounts) 
  expressed <- rownames(expressed)
    # dplyr::filter(apply(min_matrix, 1, max, na.rm = TRUE) >= minNormCounts) %>%
    # rownames()
  
  # Calculate max of mins
  # min_matrix <- as.matrix(min_cols)
  # max_of_mins <- apply(min_matrix, 1, max, na.rm = TRUE)
  # 
  # # Filter using base R (no pipe for rowname filtering)
  # expressed <- rownames(counts.df)[max_of_mins >= minNormCounts]
  expressed
}